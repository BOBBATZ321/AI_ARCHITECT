2026-02-11:
- Что сделал: Прочитал ответ, понял что нужно начать с порядка.
- Что понял: MVP — это пробный шар, пайплайн — это конвейер.
- Время: 1 час.


11.02.2026

-- Начал изучать Python на stepik
-- понял разниуц между интерпритатором и компелятором
-- Динамическая типизация - есть коробка, можешь по ложить что угодно!
# Может быть много багов из за этого
    (В Python, прежде чем сложить a + b, компьютер каждый раз должен «заглянуть в коробку» и проверить: «Так, в a у нас всё еще число? А в b? Ага, числа. А они целые или с запятой? Окей, складываю». Эти постоянные проверки делают Python медленным.).
  обход в новых версиях - def get_sum(a: int, b: int) -> int:
    return a + b (уточнения - Тут мы явно говорим: «Я жду здесь два целых числа и верну целое число».)
-- Статическая типизация - есть коробка для яблок, туда нельзя положить грушу!
-- Категории задач решаемые Python
-Системное программирование.
-Графические приложения.
-Веб-приложения.
-Интеграция компонентов.
-Приложения баз данных.

--Не подходит 
- написание ОС
- драйверов


# OS на Python: Чтобы запустить ОС, нужен интерпретатор. Но чтобы запустить интерпретатор, уже должна работать ОС. Получается замкнутый круг.#

#•  Python: Он находится «высоко над землей». У него нет прямых рычагов, чтобы дергать за контакты процессора. Он работает через кучу слоев защиты и абстракций.
•  C / Rust: Это языки «низкого уровня». На них можно написать команду, которая обращается к конкретному адресу в «железе». Это как управлять автомобилем, дергая за тросики напрямую, вместо того чтобы нажимать на кнопки в мультимедиа-системе.#


P.S. (Большинство современных приложений, работающих с данными (от мобильных приложений до сложных аналитических платформ), строятся по принципу «слоёного пирога», где «верхушка» (то, с чем ты работаешь как программист) — это обычно интерпретируемые или «полу-компилируемые» языки (Python, JavaScript, Java, C#).

Давай разберем, почему так происходит, на примере «Айсберга данных».

---

 Айсберг приложения на основе данных

 1. Верхушка (Интерпретируемая: Python / JS) — 10% кода
Это то, что пишешь ты. Здесь находится логика:
•  «Если пользователь нажал кнопку — покажи ему график».
•  «Возьми данные из этой таблицы и примени к ним формулу».
•  Почему тут не нужен компилятор (C++): Потому что логика постоянно меняется. Бизнес хочет сегодня одну кнопку, завтра другую. На интерпретируемом языке это исправить — дело секунд.

 2. Подводная часть (Компилируемая: C++ / Rust / C) — 90% мощи
Это «двигатели», которые скрыты внутри библиотек.
•  Когда ты в Python пишешь одну строчку data.sort() (отсортировать миллион строк), сам процесс сортировки происходит на C++. 
•  Базы данных (SQL, MongoDB, PostgreSQL) — они написаны на C или C++, потому что они должны очень быстро записывать биты на диск.
•  Нейросети: Твой код обучения нейронки на Python — это просто «пульт управления», а сами вычисления идут на компилируемом коде внутри видеокарты.

---

 Почему данные «любят» интерпретируемые языки?

Есть три главные причины, почему приложения для работы с данными не пишут целиком на C++:

1. Данные — это хаос (Гибкость)
Данные постоянно приходят в разном виде: то пропущена строчка, то вместо числа пришел текст. На C++ программа бы «упала» или потребовала бы написать 100 строк кода для обработки каждой мелочи. Python относится к этому проще (динамическая типизация, помнишь?), что позволяет тебе быстрее писать код для обработки ошибок.

2. Скорость разработки важнее скорости работы кода
В приложениях с данными самое дорогое — это время аналитика или ИИ-инженера. 
•  Если твоя программа на Python работает 10 секунд, а на C++ — 1 секунду, но на написание кода на Python ты потратил 1 час, а на C++ — неделю, то бизнес выберет Python. Сервера стоят дешево, а твоё время — очень дорого.

3. Интеграция (Клей)
Приложения с данными — это всегда конструктор. Тебе нужно соединить базу данных, веб-сайт, ИИ-модель и облачное хранилище. Python — лучший в мире «клей». Он легко соединяет разные куски, написанные на разных языках, в одну систему.

---

 Как это выглядит на практике (Архитектура):

Если ты строишь, например, систему рекомендаций для интернет-магазина:

1. Frontend (Интерфейс): JavaScript (интерпретируемый) — чтобы кнопочки нажимались в браузере.
2. Backend (Логика): Python (интерпретируемый) — чтобы решать, какие товары показать конкретному юзеру.
3. Database (Хранилище): PostgreSQL (написан на C — компилируемый) — чтобы мгновенно находить товары в списке из миллионов позиций.
4. ML Engine (Мозги): PyTorch (на Python + C++) — чтобы быстро считать вероятности покупки.

 Итог для тебя:
Как Архитектор ИИ, ты будешь проектировать систему так:
•  «Тяжелые» вычисления мы отдадим готовым инструментам (которые внутри скомпилированы).
•  Всю «умную» логику и связь между частями мы напишем на Python, чтобы систему можно было легко менять и развивать.

Вывод: Приложения на основе данных — это триумф интерпретируемых языков, которые «едут» на мощных компилируемых «двигателях».

Теперь пазл сложился? Понимаешь, почему Python стал королем данных, хотя он и «медленный»?)

-- что сам понял
- Почему не - описание низкоуровневых драйверов
Ответ: Драйвера - это фундамент работы системы, который в свою очередь напрямую работает с железом. Python по большей части, это красивое приложение для драйвера, где можно изменить скорость вращения вентиляторов(условно). Он задает правила для драйверов, драйвера выполняют напрямую с железом.



12.02.2026


- узнал про стандарт PEP8 
    существует, чтоб код был одинково рабочий и читаемы в независимости где и кто его писал. Есть помощники которые показывают где код не красивый и не правильный или переписывают его в нужный вид. Это Линтеры (Linters) и Автоформаттеры.

- Язык Python разработал голландский программист Гвидо Ван Россум (Guido van Rossum) в 1991 году.

13.02.2026

- еще вчера мы начали проходить print и input оказывается можно ввести input() в print(" тест" input()) и получится что я сначала введу аргумент любой, после инпут зменяет себя на мой аргумент и выводится "тест аргумент"

-sep (separator – разделитель)

- print('a', '\n', 'b', '\n', 'c', sep='*', end='#') 
a*
*b*
*c#

print('a', 'b', 'c', sep='*', end='finish')
a*b*cfinish

- новое значение переменно вытесняет старое

-В качестве названия переменных запрещено использовать ключевые (зарезервированные) слова. К ключевым словам в языке Python относятся:

    1.False;
    2.True;
    3.None;
    4. и т.д.

- num = int(input())


14.02.2026

- Продожаем изучать операторов умножения и тому подобное.

- научился вычислять арифметическую и геомитрическую прогреммию.

- научился работать с 2х и 3х значимимы числами( вычисления цифр числа и дальнейшая работа с ними)

- акказывается, если дают много формул, то при выполнении задания, можно пробовать их все, главное чтоб раюотало

- !!!прошел свой первый экзамен на stepik очень сильно затупил на последнем задании 1+11+111 = 123!!!


16.02.2026

- If else 

узнал что можно ставить проверку в проверке, то есть 

if a = 1:
	if b = 1:
		if c = 1:
			print('это работает')
		else:
			print('это работает чуть меньше')
	else:
		print('это работает чуть меньше')
else:
	print('вообще не работет')

итог дня: Пока что логически строить код в проверке if мне тяжеловато дается.


